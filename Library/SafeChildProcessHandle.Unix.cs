using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.TBA;

namespace Microsoft.Win32.SafeHandles;

// This implementation was generated by Copilot. It's going to require full rewrite if we move to dotnet/runtime.
// Just for the sake of POC, we keep it as is.
public partial class SafeChildProcessHandle
{
    protected override bool ReleaseHandle()
    {
        // On Unix, the handle is just a PID, not a real OS handle
        // No cleanup is needed
        return true;
    }

    // P/Invoke declarations
    [DllImport("libc", SetLastError = true)]
    private static extern unsafe int waitpid(int pid, int* status, int options);
    
    [DllImport("libc", SetLastError = true)]
    private static extern int kill(int pid, int sig);
    
    [DllImport("libc", SetLastError = true)]
    private static extern unsafe int posix_spawn(
        int* pid,
        byte* path,
        void* file_actions,  // posix_spawn_file_actions_t*
        void* attrp,         // posix_spawnattr_t*
        byte** argv,
        byte** envp);
    
    [DllImport("libc", SetLastError = true)]
    private static extern unsafe int posix_spawn_file_actions_init(void* file_actions);
    
    [DllImport("libc", SetLastError = true)]
    private static extern unsafe int posix_spawn_file_actions_destroy(void* file_actions);
    
    [DllImport("libc", SetLastError = true)]
    private static extern unsafe int posix_spawn_file_actions_adddup2(void* file_actions, int fildes, int newfildes);
    
    [DllImport("libc", SetLastError = true)]
    private static extern unsafe int posix_spawn_file_actions_addchdir_np(void* file_actions, byte* path);
    
    private const int WNOHANG = 1;
    private const int SIGKILL = 9;
    private const int EINTR = 4;
    private const int ECHILD = 10;
    private const int ESRCH = 3;  // No such process
    
    private static unsafe SafeChildProcessHandle StartCore(ProcessStartOptions options, SafeFileHandle inputHandle, SafeFileHandle outputHandle, SafeFileHandle errorHandle)
    {
        // Resolve executable path first
        string? resolvedPath = UnixHelpers.ResolvePath(options.FileName);
        if (string.IsNullOrEmpty(resolvedPath))
        {
            throw new Win32Exception(2, $"Cannot find executable: {options.FileName}");
        }
        
        // Prepare arguments array (argv)
        string[] argv = [resolvedPath, .. options.Arguments];
        
        // Prepare environment array (envp)
        List<string> envList = new();
        foreach (var kvp in options.Environment)
        {
            if (kvp.Value != null)
            {
                envList.Add($"{kvp.Key}={kvp.Value}");
            }
        }
        string[] envp = envList.ToArray();

        // Allocate native memory
        byte* filePathPtr = UnixHelpers.AllocateNullTerminatedUtf8String(resolvedPath);
        byte* cwdPtr = UnixHelpers.AllocateNullTerminatedUtf8String(options.WorkingDirectory?.FullName);
        byte** argvPtr = null;
        byte** envpPtr = null;
        
        // Allocate file_actions on the stack (typical size is 80 bytes, use 128 to be safe)
        byte* fileActionsBuffer = stackalloc byte[128];
        void* fileActions = fileActionsBuffer;
        bool fileActionsInitialized = false;
        
        try
        {
            // Allocate argv and envp arrays
            UnixHelpers.AllocNullTerminatedArray(argv, ref argvPtr);
            UnixHelpers.AllocNullTerminatedArray(envp, ref envpPtr);
            
            // Get file descriptors
            int stdinFd = (int)inputHandle.DangerousGetHandle();
            int stdoutFd = (int)outputHandle.DangerousGetHandle();
            int stderrFd = (int)errorHandle.DangerousGetHandle();
            
            // Initialize file actions
            if (posix_spawn_file_actions_init(fileActions) != 0)
            {
                throw new Win32Exception(Marshal.GetLastPInvokeError(), "posix_spawn_file_actions_init failed");
            }
            fileActionsInitialized = true;
            
            // Add file descriptor redirections
            if (stdinFd != 0)
            {
                int result = posix_spawn_file_actions_adddup2(fileActions, stdinFd, 0);
                if (result != 0)
                {
                    throw new Win32Exception(result, "posix_spawn_file_actions_adddup2 failed for stdin");
                }
            }
            if (stdoutFd != 1)
            {
                int result = posix_spawn_file_actions_adddup2(fileActions, stdoutFd, 1);
                if (result != 0)
                {
                    throw new Win32Exception(result, "posix_spawn_file_actions_adddup2 failed for stdout");
                }
            }
            if (stderrFd != 2)
            {
                int result = posix_spawn_file_actions_adddup2(fileActions, stderrFd, 2);
                if (result != 0)
                {
                    throw new Win32Exception(result, "posix_spawn_file_actions_adddup2 failed for stderr");
                }
            }
            
            // Add working directory change if specified (glibc 2.29+)
            if (cwdPtr != null)
            {
                // Note: addchdir_np is a non-portable extension, may not be available on all systems
                int result = posix_spawn_file_actions_addchdir_np(fileActions, cwdPtr);
                if (result != 0 && result != 38) // 38 = ENOSYS (function not implemented)
                {
                    throw new Win32Exception(result, "posix_spawn_file_actions_addchdir_np failed");
                }
            }
            
            // Spawn the process
            int pid = 0;
            int spawnResult = posix_spawn(&pid, filePathPtr, fileActions, null, argvPtr, envpPtr);
            if (spawnResult != 0)
            {
                throw new Win32Exception(spawnResult, $"posix_spawn failed for {resolvedPath}");
            }
            
            // If working directory couldn't be set via file actions, we'll have to accept it
            // The child process will inherit the parent's working directory
            
            return new SafeChildProcessHandle(pid, ownsHandle: true);
        }
        finally
        {
            // Clean up file actions
            if (fileActionsInitialized)
            {
                posix_spawn_file_actions_destroy(fileActions);
            }
            
            // Free native memory
            UnixHelpers.FreePointer(filePathPtr);
            UnixHelpers.FreePointer(cwdPtr);
            UnixHelpers.FreeArray(argvPtr, argv.Length);
            UnixHelpers.FreeArray(envpPtr, envp.Length);
        }
    }

    private int GetProcessIdCore() => (int)DangerousGetHandle();

    private unsafe bool TryGetExitCodeCore(out int exitCode)
    {
        int pid = GetProcessIdCore();
        int status = 0;
        int result = waitpid(pid, &status, WNOHANG);
        if (result == pid)
        {
            exitCode = GetExitCodeFromStatus(status);
            return true;
        }

        exitCode = -1;
        return false;
    }

    private unsafe int WaitForExitCore(int milliseconds)
    {
        int pid = GetProcessIdCore();
        int status = 0;
        
        if (milliseconds == Timeout.Infinite)
        {
            // Wait indefinitely
            while (true)
            {
                int result = waitpid(pid, &status, 0);
                if (result == pid)
                {
                    return GetExitCodeFromStatus(status);
                }
                else if (result == -1)
                {
                    int errno = Marshal.GetLastPInvokeError();
                    if (errno == EINTR) // interrupted system call, retry
                    {
                        continue;
                    }
                    throw new Win32Exception(errno, "waitpid() failed");
                }
            }
        }
        else
        {
            // Wait with timeout using polling
            long startTime = Environment.TickCount64;
            long endTime = startTime + milliseconds;
            
            while (true)
            {
                // Non-blocking wait
                int result = waitpid(pid, &status, WNOHANG);
                if (result == pid)
                {
                    return GetExitCodeFromStatus(status);
                }
                else if (result == -1)
                {
                    int errno = Marshal.GetLastPInvokeError();
                    if (errno == EINTR)
                    {
                        continue;
                    }
                    throw new Win32Exception(errno, "waitpid() failed");
                }
                else if (result == 0)
                {
                    // Process still running
                    long now = Environment.TickCount64;
                    if (now >= endTime)
                    {
                        // Timeout - terminate the process
                        KillCore(throwOnError: false);
                        
                        // Wait for it to actually exit
                        while (true)
                        {
                            result = waitpid(pid, &status, 0);
                            if (result == pid)
                            {
                                return GetExitCodeFromStatus(status);
                            }
                            else if (result == -1)
                            {
                                int errno = Marshal.GetLastPInvokeError();
                                if (errno != EINTR)
                                {
                                    throw new Win32Exception(errno, "waitpid() failed after timeout");
                                }
                            }
                        }
                    }
                    
                    // Sleep before polling again, using progressive backoff
                    int sleepMs = Math.Min((int)(now - startTime) / 10 + 1, 50);
                    Thread.Sleep(sleepMs);
                }
            }
        }
    }

    private async Task<int> WaitForExitAsyncCore(CancellationToken cancellationToken)
    {
        int pid = GetProcessIdCore();
        
        // Register cancellation to terminate the process
        using var registration = cancellationToken.Register(() =>
        {
            KillCore(throwOnError: false);
        });
        
        // Poll for process exit asynchronously
        int pollDelay = 1; // Start with 1ms
        while (!cancellationToken.IsCancellationRequested)
        {
            // Call the wait function synchronously since it's non-blocking
            (int result, int status) = WaitPidNonBlocking(pid);
            
            if (result == pid)
            {
                return GetExitCodeFromStatus(status);
            }
            else if (result == -1)
            {
                int errno = Marshal.GetLastPInvokeError();
                if (errno == EINTR)
                {
                    continue;
                }
                else if (errno == ECHILD) // no child process
                {
                    // Process already exited or doesn't exist
                    return -1;
                }
                throw new Win32Exception(errno, "waitpid() failed");
            }
            else if (result == 0)
            {
                // Process still running, wait asynchronously with progressive backoff
                await Task.Delay(pollDelay, cancellationToken).ConfigureAwait(false);
                pollDelay = Math.Min(pollDelay * 2, 50); // Progressive backoff up to 50ms
            }
        }
        
        // If we get here, we were cancelled
        throw new OperationCanceledException(cancellationToken);
    }
    
    private static unsafe (int result, int status) WaitPidNonBlocking(int pid)
    {
        int status = 0;
        int result = waitpid(pid, &status, WNOHANG);
        return (result, status);
    }
    
    private static int GetExitCodeFromStatus(int status)
    {
        // Check if the process exited normally
        if ((status & 0x7F) == 0)
        {
            // WIFEXITED - process exited normally
            return (status & 0xFF00) >> 8; // WEXITSTATUS
        }
        else
        {
            // Process was terminated by a signal
            return -1;
        }
    }

    private void KillCore(bool throwOnError)
    {
        int result = kill(GetProcessIdCore(), SIGKILL);
        if (result == 0 || !throwOnError)
        {
            return;
        }

        // Check if the process has already exited
        // ESRCH (3): No such process
        int errno = Marshal.GetLastPInvokeError();
        if (errno == ESRCH)
        {
            return;
        }

        // Any other error is unexpected
        throw new Win32Exception(errno, $"Failed to terminate process (errno={errno})");
    }
}
